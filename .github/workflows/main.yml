name: QMK Firmware Build # Nome do seu fluxo de trabalho

on:
  push:
    branches:
      - main # Aciona o workflow sempre que houver um push para a branch 'main'
  workflow_dispatch: # Permite que você acione o workflow manualmente na aba 'Actions' do GitHub

jobs:
  build:
    runs-on: ubuntu-latest # Usa uma máquina virtual Ubuntu para rodar o job

    container:
      image: qmkfirmware/qmk_cli:latest # Usa a imagem Docker oficial do QMK CLI. Ela já tem TUDO pronto!
                                       # Isso substitui a necessidade de rodar 'qmk setup' manualmente.

    steps:
    - name: Checkout repository # Pega o código do seu repositório do GitHub
      uses: actions/checkout@v4

    - name: Locate QMK Firmware path # Encontra onde o QMK Firmware está no container
      id: qmk_path
      run: |
        echo "QMK_PATH=$(qmk config user.qmk_firmware)" >> $GITHUB_OUTPUT

    - name: Copy keymap to QMK Firmware # Copia sua configuração (sua pasta 'keyboards') para o local correto
      run: |
        cp -r ${{ github.workspace }}/keyboards ${{ steps.qmk_path.outputs.QMK_PATH }}/keyboards

    - name: Build firmware # Compila o firmware
      run: |
        # MUITO IMPORTANTE: SUBSTITUA 'seu_teclado' e 'seu_keymap' pelos nomes corretos!
        # Exemplo: qmk compile -kb dz60rgb -km lucas
        qmk compile -kb seu_teclado -km seu_keymap
      working-directory: ${{ steps.qmk_path.outputs.QMK_PATH }} # Garante que a compilação ocorra no diretório QMK

    - name: Upload firmware artifact # Salva o firmware compilado como um "artefato"
      uses: actions/upload-artifact@v4
      with:
        name: qmk_firmware_bin # Nome do artefato (como ele aparecerá para download)
        # Adapte a extensão do arquivo compilado se não for .hex (pode ser .bin, .uf2, etc.)
        path: ${{ steps.qmk_path.outputs.QMK_PATH }}/*.hex
        # Se você quer todas as extensões comuns:
        # path: ${{ steps.qmk_path.outputs.QMK_PATH }}/*.{hex,bin,uf2}
